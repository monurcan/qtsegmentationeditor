#include "drawpanel.h"

#include <QImage>
#include <QMessageBox>
#include <QMouseEvent>
#include <QPainter>
#include <QtWidgets>

DrawPanel::DrawPanel(QWidget *parent) : QWidget(parent)
{
    start();
}


DrawPanel::~DrawPanel() {}


void DrawPanel::start()
{
    drawPanel = QImage(this->size(), QImage::Format_RGB32);
    drawPanel.load("/home/mehmet/Desktop/paint-qt/masks/camera_1_102.png");

    autogeneratedmask = QImage(this->size(), QImage::Format_RGB32);
    autogeneratedmask.load("/home/mehmet/Desktop/paint-qt/masks/camera_1_102.png");

    undomask = QImage(this->size(), QImage::Format_RGB32);
    undomask.load("/home/mehmet/Desktop/paint-qt/masks/camera_1_102.png");

    originalImage = QImage(this->size(), QImage::Format_RGB32);
    originalImage.load("/home/mehmet/Desktop/paint-qt/images/camera_1_102.bmp");

    setColor(Qt::black);
    setFillColor(Qt::black);
    setBrushWidth(1);
    setPenStyle(Qt::SolidLine);
    setCapStyle(Qt::RoundCap);
    setJoinStyle(Qt::RoundJoin);
    setIsLine(true);
    setIsCircle(false);
    setIsTriangle(false);
    setIsRectangle(false);
    setIsFilling(false);
    mousePressed = false;
}


bool DrawPanel::openImage()
{
     QString openImageLocation = QFileDialog::getOpenFileName(this, tr("Open image"), "", tr("PNG (*.png);;JPEG (*.jpg *.jpeg);;BMP (*.bmp)" ));
     if(!openImageLocation.isEmpty())
     {
        drawPanel.load(openImageLocation);
        return true;
     }
     else
     {
         return false;
     }
}


void DrawPanel::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton)
    {
        firstPoint = event->pos();
        lastPoint = event->pos();

        isDrawing = true;
        mousePressed = true;
    }
    update();
}


void DrawPanel::mouseMoveEvent(QMouseEvent *event)
{
    if ((event->buttons() & Qt::LeftButton) && isDrawing)
    {
        lastPoint = event->pos();
    }
    update();
}


void DrawPanel::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton && isDrawing)
    {
        isDrawing = false;
        mousePressed = false;
    }
    update();
}


void DrawPanel::paintEvent(QPaintEvent *event)
{
    static bool wasMousePressed = false;
    QRect dirtyRect = event->rect();
    QPainter painter(this);
    painter.setMatrix(_mat);
    painter.drawImage(0, 0, drawPanel);


    if(mousePressed)
    {
        if(!wasMousePressed){
            undomask = drawPanel;
        }

        wasMousePressed = true;

        if (getIsCircle())
        {
            QRect circle = QRect(firstPoint, lastPoint);
            QPainter circlePainter(this);
            circlePainter.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
            circlePainter.drawEllipse(circle);
            if(isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addEllipse(circle);
                painter.fillPath(path, fillbrush);
            }
        }
        else if (getIsRectangle())
        {
            QRect rect = QRect(firstPoint, lastPoint);
            QPainter rectanglePainter(this);
            rectanglePainter.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
            rectanglePainter.drawRect(rect);
            if (isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addRoundedRect(rect,brushWidth, brushWidth);
                painter.fillPath(path,fillbrush);
            }
        }
        else if (getIsTriangle())
        {
            QPainter trianglePainter(this);
            trianglePainter.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
            QPoint *points = new QPoint[3];
            points[0] = QPoint(firstPoint.x(), lastPoint.y());
            points[1] = QPoint(((firstPoint.x() + lastPoint.x()) / 2), firstPoint.y());
            points[2] = QPoint(lastPoint);

            QPolygon polygon;
            polygon<<points[0]<<points[1]<<points[2];
            trianglePainter.drawPolygon(polygon);
            if (isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addPolygon(polygon);
                painter.fillPath(path,fillbrush);
            }
        }
        else
        {
            QPainter pencilPainter(&drawPanel);
            pencilPainter.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
            pencilPainter.drawLine(lastPoint*matInv, firstPoint*matInv);

            QPainter pencilPainter1(&olddrawPanel);
            pencilPainter1.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
            pencilPainter1.drawLine(lastPoint*matInv, firstPoint*matInv);

            firstPoint = lastPoint;
        }
    }
    else if(wasMousePressed)
    {
        QPainter painter(&drawPanel);
        painter.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));
        QPainter painter1(&olddrawPanel);
        painter1.setPen(QPen(currentColor,brushWidth,penStyle,capStyle,joinStyle));

        if (getIsCircle())
        {
            QRect circle = QRect(firstPoint*matInv, lastPoint*matInv);
            painter.drawEllipse(circle);
            painter1.drawEllipse(circle);
            if(isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addEllipse(circle);
                painter.fillPath(path, fillbrush);
                painter1.fillPath(path, fillbrush);
            }
        }
        else if (getIsRectangle())
        {
            QRect rect = QRect(firstPoint*matInv, lastPoint*matInv);
            painter.drawRect(rect);
            painter1.drawRect(rect);
            if (isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addRoundedRect(rect,brushWidth, brushWidth);
                painter.fillPath(path,fillbrush);
                painter1.fillPath(path,fillbrush);
            }
        }
        else if (getIsTriangle())
        {
            QPoint *points = new QPoint[3];
            points[0] = QPoint(firstPoint.x(), lastPoint.y());
            points[1] = QPoint(((firstPoint.x() + lastPoint.x()) / 2), firstPoint.y());
            points[2] = QPoint(lastPoint);

            QPolygon polygon;
            polygon<<points[0]*matInv<<points[1]*matInv<<points[2]*matInv;
            painter.drawPolygon(polygon);
            painter1.drawPolygon(polygon);
            if (isFilling)
            {
                QBrush fillbrush(fillColor);
                QPainterPath path;
                path.addPolygon(polygon);
                painter.fillPath(path,fillbrush);
                painter1.fillPath(path,fillbrush);
            }
        }
        else
        {
            painter.drawImage(dirtyRect, drawPanel, dirtyRect);
        }

        wasMousePressed = false;
    }
    update();
}


void DrawPanel::resizeEvent(QResizeEvent *event)
{
    if (width() != drawPanel.width() || height() != drawPanel.height())
    {
        int nWidth, nHeight;

        if (width() > drawPanel.width())
            nWidth = width();
        if (width() <= drawPanel.width())
            nWidth = drawPanel.width();
        if (height() > drawPanel.height())
            nHeight = height();
        if (height() <= drawPanel.height())
            nHeight = drawPanel.height();

        resize(nWidth,nHeight);
    }
}


QImage DrawPanel::getImage()
{
    return drawPanel;
}

void DrawPanel::setImage(QImage image)
{
    drawPanel = image;
}

void DrawPanel::resize(int w, int h)
{
    QPixmap newImage(QSize(w, h));
    newImage.fill(Qt::white);
    QPainter painter(&newImage);
    painter.drawImage(QPoint(0, 0), drawPanel);
    setImage(newImage.toImage());
    update();
}

void DrawPanel::clear()
{
    drawPanel.fill(Qt::white);
    update();
}

QColor DrawPanel::getPrevColor() const
{
    return prevColor;
}

void DrawPanel::setPrevColor(const QColor &value)
{
    prevColor = value;
}

Qt::PenStyle DrawPanel::getPenStyle() const
{
    return penStyle;
}

void DrawPanel::setPenStyle(const Qt::PenStyle &value)
{
    penStyle = value;
}

Qt::PenCapStyle DrawPanel::getCapStyle() const
{
    return capStyle;
}

void DrawPanel::setCapStyle(const Qt::PenCapStyle &value)
{
    capStyle = value;
}

Qt::PenJoinStyle DrawPanel::getJoinStyle() const
{
    return joinStyle;
}

void DrawPanel::setJoinStyle(const Qt::PenJoinStyle &value)
{
    joinStyle = value;
}

bool DrawPanel::getIsRectangle() const
{
    return isRectangle;
}

void DrawPanel::setIsRectangle(bool value)
{
    isRectangle = value;
}

bool DrawPanel::getIsCircle() const
{
    return isCircle;
}

void DrawPanel::setIsCircle(bool value)
{
    isCircle = value;
}

bool DrawPanel::getIsTriangle() const
{
    return isTriangle;
}

void DrawPanel::setIsTriangle(bool value)
{
    isTriangle = value;
}

bool DrawPanel::getIsLine() const
{
    return isLine;
}

void DrawPanel::setIsLine(bool value)
{
    isLine = value;
}

bool DrawPanel::getIsFilling() const
{
    return isFilling;
}

void DrawPanel::setIsFilling(bool value)
{
    isFilling = value;
}

QColor DrawPanel::getFillColor() const
{
    return fillColor;
}

void DrawPanel::setFillColor(const QColor &value)
{
    fillColor = value;
}

QImage DrawPanel::getCopyDrawing() const
{
    return copyDrawing;
}

void DrawPanel::setCopyDrawing(const QImage &value)
{
    copyDrawing = value;
}

void DrawPanel::setColor(QColor setColor)
{
    currentColor = setColor;
}

void DrawPanel::setBrushWidth(int setBrushWidth)
{
    brushWidth = setBrushWidth;
}

QColor DrawPanel::getColor()
{
    return currentColor;
}

void DrawPanel::showOriginal(bool value){
    if(value){
        olddrawPanel = drawPanel;
        setImage(originalImage);
    }else {
        setImage(olddrawPanel);
    }

    update();

}

void DrawPanel::reset(){
    QPixmap newImage(drawPanel.size());
    newImage.fill(Qt::white);
    QPainter painter(&newImage);
    painter.drawImage(QPoint(0, 0), autogeneratedmask);
    setImage(newImage.toImage());

    update();
}

void DrawPanel::undo(){
    QPixmap newImage(drawPanel.size());
    newImage.fill(Qt::white);
    QPainter painter(&newImage);
    painter.drawImage(QPoint(0, 0), undomask);
    setImage(newImage.toImage());

    update();
}

QImage DrawPanel::Mat2QImage(Mat const& src)
{
     Mat temp; // make the same cv::Mat
     cvtColor(src, temp,cv::COLOR_BGR2RGB); // cvtColor Makes a copt, that what i need
     QImage dest((const uchar *) temp.data, temp.cols, temp.rows, temp.step, QImage::Format_RGB888);
     dest.bits(); // enforce deep copy, see documentation
     // of QImage::QImage ( const uchar * data, int width, int height, Format format )
     return dest;
}

void DrawPanel::erosion(){
    undomask = drawPanel;

    Mat erosion_dst;
    int erosion_size = 2;
    int erosion_type = MORPH_CROSS;

    Mat src(drawPanel.height(),drawPanel.width(),CV_8UC4,(uchar*)drawPanel.bits(),drawPanel.bytesPerLine());
    Mat element = getStructuringElement( erosion_type,
                         Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                         Point( erosion_size, erosion_size ) );
    erode( src, erosion_dst, element );

    QImage erodeimg = Mat2QImage(erosion_dst);

    QPixmap newImage(drawPanel.size());
    newImage.fill(Qt::white);
    QPainter painter(&newImage);
    painter.drawImage(QPoint(0, 0), erodeimg);
    setImage(newImage.toImage());

    update();
}

void DrawPanel::dilation(){
    undomask = drawPanel;

    Mat erosion_dst;
    int erosion_size = 2;
    int erosion_type = MORPH_CROSS;

    Mat src(drawPanel.height(),drawPanel.width(),CV_8UC4,(uchar*)drawPanel.bits(),drawPanel.bytesPerLine());
    Mat element = getStructuringElement( erosion_type,
                         Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                         Point( erosion_size, erosion_size ) );
    dilate( src, erosion_dst, element );

    QImage erodeimg = Mat2QImage(erosion_dst);

    QPixmap newImage(drawPanel.size());
    newImage.fill(Qt::white);
    QPainter painter(&newImage);
    painter.drawImage(QPoint(0, 0), erodeimg);
    setImage(newImage.toImage());

    update();

}

void DrawPanel::wheelEvent(QWheelEvent *pQEvent)
{
//  qDebug() << "Wheel Event:";
  //qDebug() << "mouse pos:" << pQEvent->pos();
  // pos() -> virtual canvas
  bool matInvOK = false;
  matInv = _mat.inverted(&matInvOK);
  if (!matInvOK) {
    qDebug() << "View matrix not invertible!";
    return;
  }
  QPointF posNDC
    = QPointF(pQEvent->pos().x(), pQEvent->pos().y()) * matInv;
  //qDebug() << "mouse pos (NDC):" << posNDC;
  float delta = 1.0f + pQEvent->angleDelta().y() / 1200.0f;
  //qDebug() << "angleDelta:" << pQEvent->angleDelta().y();
  //qDebug() << "scale factor:" << delta;
  _mat.translate(posNDC.x(), posNDC.y()); // origin to spot
  _mat.scale(delta, delta); // scale
  _mat.translate(-posNDC.x(), -posNDC.y()); // spot to origin

  update();
  pQEvent->accept();
}
